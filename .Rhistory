print(node$children)
if (x[row, node$split_attribute] > node$split_value) {
node <- node$Bigger
} else {
node <- node$Smaller
}
}
print(node)
y[row] <- node$label
}
return(y)
}
tree <- tree.grow(credit.x_1, credit.y, 2, 1, credit.nfeat)
tree.classify(credit.x_2, tree)
tree.classify <- function(x, tr) {
y <- NULL
for (row in nrow(x)) {
node <- tr
while(!is.null(node$children[[1]])) {
print(node$children)
if (x[row, node$split_attribute] > node$split_value) {
node <- node$Bigger
} else {
node <- node$Smaller
}
}
print(node)
y[row] <- node$label
}
return(y)
}
tree.classify(credit.x_2, tree)
tree.classify <- function(x, tr) {
y <- NULL
for (row in nrow(x)) {
node <- tr
while(!isLeaf(node)) {
print(node$children)
if (x[row, node$split_attribute] > node$split_value) {
node <- node$Bigger
} else {
node <- node$Smaller
}
}
print(node)
y[row] <- node$label
}
return(y)
}
tree.classify(credit.x_2, tree)
tree.classify <- function(x, tr) {
y <- NULL
for (row in nrow(x)) {
node <- tr
while(!isLeaf(node)) {
# print(node$children)
if (x[row, node$split_attribute] > node$split_value) {
node <- node$Bigger
} else {
node <- node$Smaller
}
}
print(node)
y[row] <- node$label
}
return(y)
}
tree.classify <- function(x, tr) {
y <- NULL
for (row in nrow(x)) {
node <- tr
while(!isLeaf(node)) {
# print(node$children)
if (x[row, node$split_attribute] > node$split_value) {
node <- node$Bigger
} else {
node <- node$Smaller
}
}
print(node)
y[row] <- node$label
}
return(y)
}
tree.classify(credit.x_2, tree)
tree.classify <- function(x, tr) {
y <- NULL
for (row in 1:nrow(x)) {
node <- tr
while(!isLeaf(node)) {
# print(node$children)
if (x[row, node$split_attribute] > node$split_value) {
node <- node$Bigger
} else {
node <- node$Smaller
}
}
print(node)
y[row] <- node$label
}
return(y)
}
tree.classify(credit.x_2, tree)
credit <- read.csv('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/credit.txt', header = TRUE)
credit.y <- credit[,6]
credit.y <- credit[,6]
credit.x_1 <- credit[1:10,1:5]
credit.x_2 <- credit[11:12, 1:5]
credit.nfeat <- length(credit.x_1[1,])
tree <- tree.grow(credit.x_1, credit.y, 2, 1, credit.nfeat)
tree.classify(credit.x_2, tree)
tree.classify <- function(x, tr) {
y <- NULL
for (row in 1:nrow(x)) {
node <- tr
while(!isLeaf(node)) {
if (x[row, node$split_attribute] > node$split_value) {
node <- node$Bigger
} else {
node <- node$Smaller
}
}
y[row] <- node$label
}
return(y)
}
tree.classify(credit.x_2, tree)
credit.x_1 <- credit[1:10,1:5]
print(credit.x_1)
credit.y <- credit[1:10,6]
credit.x_1 <- credit[1:10,1:5]
credit.x_2 <- credit[11:12, 1:5]
credit.nfeat <- length(credit.x_1[1,])
tree <- tree.grow(credit.x_1, credit.y, 2, 1, credit.nfeat)
tree.classify(credit.x_2, tree)
# Returns the best split for an attribute of the dataset
best_split <- function(x, x_row, y, minleaf) {
parent_i <- impurity.gini(y)
x.sorted <- sort(unique(x))
x.length <- length(x.sorted)
x.splitpoints <- (x.sorted[1:x.length-1]+x.sorted[2:x.length])/2
best_reduction <- -999
# Loop over the data to determine the best split point based on impurity reduction
for (val in x.splitpoints) {
big_split <- y[x > val]
small_split <- y[x <= val]
big_imp <- impurity.gini(big_split)
small_imp <- impurity.gini(small_split)
reduction_imp = parent_i -(small_imp * (length(small_split)/length(x))+big_imp*(length(big_split)/length(x)))
if (length(small_split) >= minleaf && length(big_split) >= minleaf) {
if (reduction_imp > best_reduction) {
best_split_point <- val
best_reduction <- reduction_imp
best_split_rows <- list(x_row[x > val], x_row[x <= val])
}
}
}
if (best_split_point == -999) {
return(NULL)
}
return(list(best_reduction, best_split_point, unlist(best_split_rows[1]), unlist(best_split_rows[2])))
}
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
credit <- read.csv('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/eclipse-metrics-packages-2.0.csv', header = TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
credit <- read.csv('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/eclipse-metrics-packages-2.0.csv')
print(credit)
credit <- read.csv('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/eclipse-metrics-packages-2.0.csv', header = TRUE)
print(credit[, 1])
credit <- read.csv2('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/eclipse-metrics-packages-2.0.csv', header = TRUE)
print(credit)
print(credit[,1])
print(credit)
print(credit[1,])
credit <- read.csv2('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/eclipse-metrics-packages-2.0.csv', header = FALSE)
credit <- subset(credit, select = -c(1,2))
print(credit)
credit <- credit[-c(1,2)]
print(credit)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
print(best_split_rows$l_data)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
tree <- tree.grow(credit.x_1, credit.y, 2, 1, credit.nfeat)
return(append(best_reduction, best_split_point, best_split_rows))
# Returns the best split for an attribute of the dataset
best_split <- function(x, x_row, y, minleaf) {
parent_i <- impurity.gini(y)
x.sorted <- sort(unique(x))
x.length <- length(x.sorted)
x.splitpoints <- (x.sorted[1:x.length-1]+x.sorted[2:x.length])/2
best_split_point <- -999
best_reduction <- -999
# Loop over the data to determine the best split point based on impurity reduction
for (val in x.splitpoints) {
big_split <- y[x > val]
small_split <- y[x <= val]
big_imp <- impurity.gini(big_split)
small_imp <- impurity.gini(small_split)
reduction_imp = parent_i -(small_imp * (length(small_split)/length(x))+big_imp*(length(big_split)/length(x)))
if (length(small_split) >= minleaf && length(big_split) >= minleaf) {
if (reduction_imp > best_reduction) {
best_split_point <- val
best_reduction <- reduction_imp
best_split_rows <- list(x_row[x > val], x_row[x <= val])
}
}
}
if (best_split_point == -999) {
return(NULL)
}
return(append(best_reduction, best_split_point, best_split_rows))
}
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
tree <- tree.grow(credit.x_1, credit.y, 2, 1, credit.nfeat)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
impurity.reduction <- function(x, y, parent_i, val) {
left_split <- y[x > val]
right_split <- y[x <= val]
left_imp <- impurity.gini(left_split)
right_imp <- impurity.gini(right_split)
reduction_imp = parent_i -(right_imp * (length(right_split)/length(x))+left_imp*(length(left_split)/length(x)))
}
# Returns the best split for an attribute of the dataset
best.split <- function(x, x_row, y, minleaf) {
parent_i <- impurity.gini(y)
x_sorted <- sort(unique(x))
x_length <- length(x_sorted)
x_splitpoints <- (x_sorted[1:x_length-1]+x_sorted[2:x_length])/2
best_splitpoint <- -999
best_reduction <- -999
# Loop over the data to determine the best split point based on impurity reduction
for (val in x_splitpoints) {
reduction_imp <- impurity.reduction(x, y, parent_i, val)
if (length(right_split) >= minleaf && length(left_split) >= minleaf) {
if (reduction_imp > best_reduction) {
best_splitpoint <- val
best_reduction <- reduction_imp
best_splitrows <- list(x_row[x > val], x_row[x <= val])
}
}
}
if (best_splitpoint == -999) {
return(NULL)
}
return(append(c(best_reduction, best_splitpoint),best_splitrows))
}
# Determine the best split over all of the attributes at a certain node
get.split <- function(x_row, y, nfeat, minleaf) {
x <- credit[x_row, ]
b_gini <- 0
for (i in 1:nfeat){
split <- best.split(x[,i], x_row, y, minleaf)
if (is.null(split)) next
gini <- unlist(split[1])
# The best split is the split with best reduction
if (gini > b_gini){
b_gini <- gini
b_split <- append(i,split[2:4])
}
}
return(b_split)
}
to.leaf <- function(node) {
max_index <- which.max(node$dataY)
node$Set(label = node$dataY[max_index])
}
tree.grow <- function(x, y, nmin, minleaf, nfeat){
attribute_names = colnames(x)
root <- Node$new('start', dataX = c(1:length(x[,1])), dataY = y)
nodelist <- list(root)
while(length(nodelist) > 0) {
node <- nodelist[[1]]
nodelist[[1]] <- NULL
if (impurity.gini(node$dataY) > 0 && length(node$dataY) >= nmin) {
split <- get.split(node$dataX, node$dataY, nfeat, minleaf)
split_attribute <- split[[1]]
split_value <- split[[2]]
left_data <- split[[3]]
right_data <- split[[4]]
left_y <- y[left_data]
right_y <- y[right_data]
node$Set(splitAttribute = attribute_names[split_attribute], splitValue = split_value)
leftchild <- node$AddChild('leftChild', dataX = left_data, dataY = left_y)
rightchild <- node$AddChild('rightChild', dataX = right_data, dataY = right_y)
nodelist <- c(nodelist, list(leftchild, rightchild))
} else {
to.leaf(node)
}
}
print(root, 'splitAttribute', "splitValue", "dataY", "label")
return(root)
}
tree.classify <- function(x, tr) {
y <- NULL
for (row in 1:nrow(x)) {
node <- tr
while(!isLeaf(node)) {
if (x[row, node$splitAttribute] > node$splitValue) {
node <- node$leftChild
} else {
node <- node$rightChild
}
}
y[row] <- node$label
}
return(y)
}
credit <- read.csv('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/credit.txt', header = TRUE)
credit.y <- credit[1:10,6]
credit.x_1 <- credit[1:10,1:5]
credit.x_2 <- credit[11:12, 1:5]
credit.nfeat <- length(credit.x_1[1,])
tree <- tree.grow(credit.x_1, credit.y, 2, 1, credit.nfeat)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
tree.grow.bag(credit.x_1, credit.y, 2, 1, credit.nfeat, 5)
tree.grow.bag <- function(x, y, nmin, minleaf, nfeat, m) {
trees <- c()
for (i in 1:m) {
samples <- sample(nrow(x), nrow(x), TRUE)
}
}
tree.grow.bag(credit.x_1, credit.y, 2, 1, credit.nfeat, 5)
tree.grow.bag <- function(x, y, nmin, minleaf, nfeat, m) {
trees <- c()
for (i in 1:m) {
samples <- sample(nrow(x), nrow(x), TRUE)
print(samples)
}
}
tree.grow.bag(credit.x_1, credit.y, 2, 1, credit.nfeat, 5)
tree.grow.bag <- function(x, y, nmin, minleaf, nfeat, m) {
trees <- c()
for (i in 1:m) {
samples <- sample(nrow(x), nrow(x), TRUE)
trees <- append(trees, tree.grow(x[samples, ], y[samples], nmin, minleaf, nfeat))
}
return(trees)
}
tree.grow.bag(credit.x_1, credit.y, 2, 1, credit.nfeat, 5)
tree.classify.bag <- function(x, tr) {
predictions <- c()
for (i in 1:nrow(x)) {
labels <- c()
for (tree in tr) {
labels <- append(labels, tree.classify(x, tree))
}
max_index <- which.max(labels)
predictions[i] <- labels[max_index]
}
}
trees <- tree.grow.bag(credit.x_1, credit.y, 2, 1, credit.nfeat, 5)
tree.classify.bag(credit.x_2, trees)
return(predictions)
tree.classify.bag <- function(x, tr) {
predictions <- c()
for (i in 1:nrow(x)) {
labels <- c()
for (tree in tr) {
labels <- append(labels, tree.classify(x, tree))
}
max_index <- which.max(labels)
predictions[i] <- labels[max_index]
}
return(predictions)
}
tree.classify.bag(credit.x_2, trees)
tree.classify.bag <- function(x, tr) {
predictions <- c()
for (i in 1:nrow(x)) {
labels <- c()
for (tree in tr) {
labels <- append(labels, tree.classify(x, tree))
}
max_index <- which.max(labels)
print(labels[max_index])
predictions[i] <- labels[max_index]
}
return(predictions)
}
tree.classify.bag(credit.x_2, trees)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
trees <- tree.grow.bag(credit.x_1, credit.y, 2, 1, credit.nfeat, 5)
tree.classify.bag(credit.x_2, trees)
trees <- tree.grow.bag(credit.x_1, credit.y, 2, 1, credit.nfeat, 5)
tree.classify.bag(credit.x_2, trees)
trees <- tree.grow.bag(credit.x_1, credit.y, 2, 1, credit.nfeat, 5)
tree.classify.bag(credit.x_2, trees)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
tree <- tree.grow(credit.x_1, credit.y, 2, 1, credit.nfeat)
tree.classify(credit.x_2, tree)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
data_eclipse_2.0 <- read.csv2('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/eclipse-metrics-packages-2.0', header = TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
data_eclipse_2.0 <- data_eclipse_2.0[,c(3, 5:45)]
print(ncol(data_eclipse_2.0))
data_eclipse_2.0 <- data_eclipse_2.0[,c(3, 5:44)]
data_eclipse_2.0 <- read.csv2('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/eclipse-metrics-packages-2.0.csv')
data_eclipse_2.0 <- data_eclipse_2.0[,c(3, 5:44)]
print(ncol(data_eclipse_2.0))
eclipse_2.0 <- read.csv2('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/eclipse-metrics-packages-2.0.csv')
data_eclipse_2.0 <- eclipse_2.0[,c(3, 5:44)]
eclipse_2.0_labels <- eclipse_2.0[,4]
tree.grow(data_eclipse_2.0, eclipse_2.0_labels, 15, 5, 41)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
tree.grow(data_eclipse_2.0, eclipse_2.0_labels, 15, 5, 41)
tree.grow(data_eclipse_2.0, eclipse_2.0_labels, 15, 5, 41)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
print(eclipse_2.0_labels)
tree.grow(data_eclipse_2.0, eclipse_2.0_labels, 15, 5, 41)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
eclipse_2.0 <- read.csv2('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/eclipse-metrics-packages-2.0.csv')
data_eclipse_2.0 <- eclipse_2.0[,c(3, 5:44)]
print(data_eclipse_2.0)
max.print(data_eclipse_2.0)
data_eclipse_2.0
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
print(labels)
print(eclipse_3.0_labels)
print(labels)

best_big_split = c()
cs= 0
cb= 0
for (i in 1:length(x)){
if (x[i] < best_split_point) {
best_small_split[cs] = i
cs = cs+1
} else {
best_big_split[cb] = i
cb = cb+1
}
}
}
}
}
return(list(best_reduction, best_split_point, best_big_split, best_small_split))
}
get_split(credit.x, credit.y, credit.nfeat)
# Returns the best split for an attribute of the dataset
best_split <- function(x, y) {
parent_i <- impurity.gini(y)
x.sorted <- sort(unique(x))
x.length <- length(x.sorted)
# Acount for the binary values for faster computation
if (x.length == 2){
best_split_point <- 0.5
big_split <- y[x > 0.5]
small_split <- y[x <= 0.5]
best_reduction <- parent_i -(impurity.gini(small_split) * (length(small_split)/length(x))+ impurity.gini(big_split)*(length(big_split)/length(x)))
best_small_split = c()
best_big_split = c()
cs = 1
cb = 1
for (i in 1:length(x)){
if (x[i] < best_split_point) {
best_small_split[cs] = i
cs = cs+1
} else {
best_big_split[cb] = i
cb = cb+1
}
}
} else {
x.splitpoints <- x.sorted[2]
x.splitpoints <- (x.sorted[1:x.length-1]+x.sorted[2:x.length])/2
best_split_point <- 0
best_reduction <- 0
# Loop over the data to determine the best split point based on impurity reduction
for (val in x.splitpoints) {
big_split <- y[x > val]
small_split <- y[x <= val]
big_imp <- impurity.gini(big_split)
small_imp <- impurity.gini(small_split)
reduction_imp = parent_i -(small_imp * (length(small_split)/length(x))+big_imp*(length(big_split)/length(x)))
if (reduction_imp > best_reduction) {
best_split_point <- val
best_reduction <- reduction_imp
best_small_split = c()
best_big_split = c()
cs= 1
cb= 1
for (i in 1:length(x)){
if (x[i] < best_split_point) {
best_small_split[cs] = i
cs = cs+1
} else {
best_big_split[cb] = i
cb = cb+1
}
}
}
}
}
return(list(best_reduction, best_split_point, best_big_split, best_small_split))
}
get_split(credit.x, credit.y, credit.nfeat)
get_x_index <- function(x){
best_small_split = c()
best_big_split = c()
cs= 1
cb= 1
for (i in 1:length(x)){
if (x[i] < best_split_point) {
best_small_split[cs] = i
cs = cs+1
} else {
best_big_split[cb] = i
cb = cb+1
}
}
return(list(best_big_split, best_small_split))
}
# Returns the best split for an attribute of the dataset
best_split <- function(x, y) {
parent_i <- impurity.gini(y)
x.sorted <- sort(unique(x))
x.length <- length(x.sorted)
# Acount for the binary values for faster computation
if (x.length == 2){
best_split_point <- 0.5
big_split <- y[x > 0.5]
small_split <- y[x <= 0.5]
best_reduction <- parent_i -(impurity.gini(small_split) * (length(small_split)/length(x))+ impurity.gini(big_split)*(length(big_split)/length(x)))
best_x_rows <- get_x_index(x)
} else {
x.splitpoints <- x.sorted[2]
x.splitpoints <- (x.sorted[1:x.length-1]+x.sorted[2:x.length])/2
best_split_point <- 0
best_reduction <- 0
# Loop over the data to determine the best split point based on impurity reduction
for (val in x.splitpoints) {
big_split <- y[x > val]
small_split <- y[x <= val]
big_imp <- impurity.gini(big_split)
small_imp <- impurity.gini(small_split)
reduction_imp = parent_i -(small_imp * (length(small_split)/length(x))+big_imp*(length(big_split)/length(x)))
if (reduction_imp > best_reduction) {
best_split_point <- val
best_reduction <- reduction_imp
best_split_rows = get_x_index(x)
}
}
}
return(list(best_reduction, best_split_point, best_split_rows[1], best_split_rows[2]))
}
get_split(credit.x, credit.y, credit.nfeat)
# Returns the best split for an attribute of the dataset
best_split <- function(x, y) {
parent_i <- impurity.gini(y)
x.sorted <- sort(unique(x))
x.length <- length(x.sorted)
# Acount for the binary values for faster computation
if (x.length == 2){
best_split_point <- 0.5
big_split <- y[x > 0.5]
small_split <- y[x <= 0.5]
best_reduction <- parent_i -(impurity.gini(small_split) * (length(small_split)/length(x))+ impurity.gini(big_split)*(length(big_split)/length(x)))
best_split_rows <- get_x_index(x)
} else {
x.splitpoints <- x.sorted[2]
x.splitpoints <- (x.sorted[1:x.length-1]+x.sorted[2:x.length])/2
best_split_point <- 0
best_reduction <- 0
# Loop over the data to determine the best split point based on impurity reduction
for (val in x.splitpoints) {
big_split <- y[x > val]
small_split <- y[x <= val]
big_imp <- impurity.gini(big_split)
small_imp <- impurity.gini(small_split)
reduction_imp = parent_i -(small_imp * (length(small_split)/length(x))+big_imp*(length(big_split)/length(x)))
if (reduction_imp > best_reduction) {
best_split_point <- val
best_reduction <- reduction_imp
best_split_rows = get_x_index(x)
}
}
}
return(list(best_reduction, best_split_point, best_split_rows[1], best_split_rows[2]))
}
get_split(credit.x, credit.y, credit.nfeat)
# Returns the best split for an attribute of the dataset
best_split <- function(x, y) {
parent_i <- impurity.gini(y)
x.sorted <- sort(unique(x))
x.length <- length(x.sorted)
# Acount for the binary values for faster computation
if (x.length == 2){
best_split_point <- 0.5
big_split <- y[x > 0.5]
small_split <- y[x <= 0.5]
best_reduction <- parent_i -(impurity.gini(small_split) * (length(small_split)/length(x))+ impurity.gini(big_split)*(length(big_split)/length(x)))
best_split_rows <- get_x_index(x, best_split_point)
} else {
x.splitpoints <- x.sorted[2]
x.splitpoints <- (x.sorted[1:x.length-1]+x.sorted[2:x.length])/2
best_split_point <- 0
best_reduction <- 0
# Loop over the data to determine the best split point based on impurity reduction
for (val in x.splitpoints) {
big_split <- y[x > val]
small_split <- y[x <= val]
big_imp <- impurity.gini(big_split)
small_imp <- impurity.gini(small_split)
reduction_imp = parent_i -(small_imp * (length(small_split)/length(x))+big_imp*(length(big_split)/length(x)))
if (reduction_imp > best_reduction) {
best_split_point <- val
best_reduction <- reduction_imp
best_split_rows = get_x_index(x, best_split_point)
}
}
}
return(list(best_reduction, best_split_point, best_split_rows[1], best_split_rows[2]))
}
get_x_index <- function(x, split_point){
best_small_split = c()
best_big_split = c()
cs= 1
cb= 1
for (i in 1:length(x)){
if (x[i] < split_point) {
best_small_split[cs] = i
cs = cs+1
} else {
best_big_split[cb] = i
cb = cb+1
}
}
return(list(best_big_split, best_small_split))
}
get_split(credit.x, credit.y, credit.nfeat)
tree.grow(credit.x, credit.y, 2, 1, credit.nfeat)
# Determine the best split over all of the attributes at a certain node
get_split <- function(x, y, nfeat) {
b_gini <- 0
for (i in 1:nfeat){
split <- best_split(x[,i], y)
gini <- unlist(split[1])
# The best split is the split with best reduction
if (gini > b_gini){
b_gini <- gini
b_split <- append(i,split[2:4])
}
}
return(b_split)
}
get_split(credit.x, credit.y, credit.nfeat)
tree.grow(credit.x, credit.y, 2, 1, credit.nfeat)
print(credit[0])
print(credit$data)
credit <- read.csv('C:/Users/Lisa/Desktop/UU/Data_Mining/Assignment_1/credit.txt', header = TRUE)
print(credit$data)
print(credit)
print(colnames(credit))
tree.grow <- function(x, y, nmin, minleaf, nfeat){
store <- Dict$new(items = NULL)
root <- get_split(x, y, nfeat)
attributes <- colnames(x)
root_name <- attribute(root[1])
print(root_name)
}
tree.grow(credit.x, credit.y, 2, 1, credit.nfeat)
tree.grow <- function(x, y, nmin, minleaf, nfeat){
store <- Dict$new(items = NULL)
root <- get_split(x, y, nfeat)
attributes <- colnames(x)
root_name <- attribute[root[1]]
print(root_name)
}
tree.grow(credit.x, credit.y, 2, 1, credit.nfeat)
tree.grow <- function(x, y, nmin, minleaf, nfeat){
store <- Dict$new(items = NULL)
root <- get_split(x, y, nfeat)
attributes <- colnames(x)
root_name <- attributes[root[1]]
print(root_name)
}
tree.grow(credit.x, credit.y, 2, 1, credit.nfeat)
tree.grow <- function(x, y, nmin, minleaf, nfeat){
store <- Dict$new(items = NULL)
root <- get_split(x, y, nfeat)
attributes <- colnames(x)
root_name <- attributes[unlist(root[1])]
print(root_name)
}
tree.grow(credit.x, credit.y, 2, 1, credit.nfeat)
source('C:/Users/Lisa/Desktop/UU/Data_Mining/Assignment_1/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining/Assignment_1/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining/Assignment_1/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining/Assignment_1/Assignment_1_code.R', echo=TRUE)
tree.grow <- function(x, y, nmin, minleaf, nfeat){
store <- Dict$new(items = NULL)
root <- get_split(x, y, nfeat)
# Get the attribute names
attributes <- colnames(x)
root_name <- attributes[unlist(root[1])]
tree <- Node$new(root_name)
tree$AddChild(attributes(3))
plot(tree)
}
tree.grow(credit.x, credit.y, 2, 1, credit.nfeat)
tree.grow <- function(x, y, nmin, minleaf, nfeat){
store <- Dict$new(items = NULL)
root <- get_split(x, y, nfeat)
# Get the attribute names
attributes <- colnames(x)
root_name <- attributes[unlist(root[1])]
tree <- Node$new(root_name)
child_name<-tree$AddChild(attributes(3))
plot(tree)
}
tree.grow(credit.x, credit.y, 2, 1, credit.nfeat)
tree.grow <- function(x, y, nmin, minleaf, nfeat){
store <- Dict$new(items = NULL)
root <- get_split(x, y, nfeat)
# Get the attribute names
attributes <- colnames(x)
root_name <- attributes[unlist(root[1])]
tree <- Node$new(root_name)
tree$AddChild(attributes[3])
plot(tree)
}
tree.grow(credit.x, credit.y, 2, 1, credit.nfeat)
tree.grow <- function(x, y, nmin, minleaf, nfeat){
store <- Dict$new(items = NULL)
root <- get_split(x, y, nfeat)
# Get the attribute names
attributes <- colnames(x)
root_name <- attributes[unlist(root[1])]
tree <- Node$new(root_name)
tree$AddChild(attributes[3])
tree$AddChild(attributes[5])
}
tree.grow(credit.x, credit.y, 2, 1, credit.nfeat)
tree.grow <- function(x, y, nmin, minleaf, nfeat){
store <- Dict$new(items = NULL)
root <- get_split(x, y, nfeat)
# Get the attribute names
attributes <- colnames(x)
root_name <- attributes[unlist(root[1])]
tree <- Node$new(root_name)
tree$AddChild(attributes[3])
tree$AddChild(attributes[5])
plot(tree)
}
tree.grow(credit.x, credit.y, 2, 1, credit.nfeat)
tree.grow <- function(x, y, nmin, minleaf, nfeat){
store <- Dict$new(items = NULL)
root <- get_split(x, y, nfeat)
# Get the attribute names
attributes <- colnames(x)
root_name <- attributes[unlist(root[1])]
level <- 1
tree <- Node$new(root_name)
store$Set(paste0(toString(level), left), x[3])
store$Set(paste0(toString(level), right), x[4])
print(store)
}
tree.grow(credit.x, credit.y, 2, 1, credit.nfeat)
tree.grow <- function(x, y, nmin, minleaf, nfeat){
store <- Dict$new(items = NULL)
root <- get_split(x, y, nfeat)
# Get the attribute names
attributes <- colnames(x)
root_name <- attributes[unlist(root[1])]
level <- 1
tree <- Node$new(root_name)
store$Set(paste(toString(level), left), x[3])
store$Set(paste(toString(level), right), x[4])
print(store)
}
tree.grow(credit.x, credit.y, 2, 1, credit.nfeat)
tree.grow <- function(x, y, nmin, minleaf, nfeat){
store <- Dict$new(items = NULL)
root <- get_split(x, y, nfeat)
# Get the attribute names
attributes <- colnames(x)
root_name <- attributes[unlist(root[1])]
level <- 1
tree <- Node$new(root_name)
store$Set(paste(toString(level), "left"), x[3])
store$Set(paste(toString(level), "right"), x[4])
print(store)
}
tree.grow(credit.x, credit.y, 2, 1, credit.nfeat)
print(paste(toString(1), "left"))
tree.grow <- function(x, y, nmin, minleaf, nfeat){
store <- Dict$new(items = NULL)
root <- get_split(x, y, nfeat)
# Get the attribute names
attributes <- colnames(x)
root_name <- attributes[unlist(root[1])]
level <- 1
tree <- Node$new(root_name)
left <- paste(toString(level), "left")
store$Set(left, x[3])
store$Set(paste(toString(level), "right"), x[4])
print(store)
}
tree.grow(credit.x, credit.y, 2, 1, credit.nfeat)
tree.grow <- function(x, y, nmin, minleaf, nfeat){
store <- Dict$new(items = NULL)
root <- get_split(x, y, nfeat)
# Get the attribute names
attributes <- colnames(x)
root_name <- attributes[unlist(root[1])]
level <- 1
tree <- Node$new(root_name)
store$set(paste(toString(level), "left"), x[3])
store$set(paste(toString(level), "right"), x[4])
print(store)
}
tree.grow(credit.x, credit.y, 2, 1, credit.nfeat)
tree.grow <- function(x, y, nmin, minleaf, nfeat){
store <- Dict$new(items = NULL)
root <- get_split(x, y, nfeat)
# Get the attribute names
attributes <- colnames(x)
root_name <- attributes[unlist(root[1])]
level <- 1
tree <- Node$new(root_name)
store$set(paste(toString(level), "left"), x[3])
store$set(paste(toString(level), "right"), x[4])
print(store$keys())
}
tree.grow(credit.x, credit.y, 2, 1, credit.nfeat)
tree.grow <- function(x, y, nmin, minleaf, nfeat){
store <- Dict$new(items = NULL)
root <- get_split(x, y, nfeat)
# Get the attribute names
attributes <- colnames(x)
root_name <- attributes[unlist(root[1])]
level <- 1
tree <- Node$new(root_name)
store$set(paste(toString(level), "left"), x[3])
store$set(paste(toString(level), "right"), x[4])
print(store$values())
}
tree.grow(credit.x, credit.y, 2, 1, credit.nfeat)
tree.grow <- function(x, y, nmin, minleaf, nfeat){
store <- Dict$new(items = NULL)
root_split <- get_split(x, y, nfeat)
# Get the attribute names
attributes <- colnames(x)
root_name <- attributes[unlist(root_split[1])]
level <- 1
tree <- Node$new(root_name)
store$set(paste(toString(level), "left"), root[3])
store$set(paste(toString(level), "right"), root[4])
print(store$values())
}
source('C:/Users/Lisa/Desktop/UU/Data_Mining/Assignment_1/Assignment_1_code.R', echo=TRUE)
tree.grow <- function(x, y, nmin, minleaf, nfeat){
store <- Dict$new(items = NULL)
root_split <- get_split(x, y, nfeat)
# Get the attribute names
attributes <- colnames(x)
root_name <- attributes[unlist(root_split[1])]
level <- 1
tree <- Node$new(root_name)
store$set(paste(toString(level), "left"), root_split[3])
store$set(paste(toString(level), "right"), root_split[4])
print(store$values())
}
tree.grow(credit.x, credit.y, 2, 1, credit.nfeat)
source('C:/Users/Lisa/Desktop/UU/Data_Mining/Assignment_1/Assignment_1_code.R', echo=TRUE)
tree.grow <- function(x, y, nmin, minleaf, nfeat){
store <- Dict$new(items = NULL)
root_split <- get_split(x, y, nfeat)
# Get the attribute names
attributes <- colnames(x)
root_name <- attributes[unlist(root_split[1])]
level <- 1
tree <- Node$new(root_name, split_point = root_split[2], data_l = root_split[3], data_r = root_split[4])
# store$set(paste(toString(level), "left"), root_split[3])
# store$set(paste(toString(level), "right"), root_split[4])
# print(store$values())
}
tree.grow(credit.x, credit.y, 2, 1, credit.nfeat)
tree.grow <- function(x, y, nmin, minleaf, nfeat){
store <- Dict$new(items = NULL)
root_split <- get_split(x, y, nfeat)
# Get the attribute names
attributes <- colnames(x)
root_name <- attributes[unlist(root_split[1])]
level <- 1
tree <- Node$new(root_name, split_point = root_split[2], data_l = root_split[3], data_r = root_split[4])
print(tree)
# store$set(paste(toString(level), "left"), root_split[3])
# store$set(paste(toString(level), "right"), root_split[4])
# print(store$values())
}
tree.grow(credit.x, credit.y, 2, 1, credit.nfeat)
tree.grow <- function(x, y, nmin, minleaf, nfeat){
store <- Dict$new(items = NULL)
root_split <- get_split(x, y, nfeat)
# Get the attribute names
attributes <- colnames(x)
root_name <- attributes[unlist(root_split[1])]
level <- 1
tree <- Node$new(root_name, split_point = root_split[2], data_l = root_split[3], data_r = root_split[4])
print(tree, "split_point", "data_l", "data_r")
# store$set(paste(toString(level), "left"), root_split[3])
# store$set(paste(toString(level), "right"), root_split[4])
# print(store$values())
}
tree.grow(credit.x, credit.y, 2, 1, credit.nfeat)
tree.grow <- function(x, y, nmin, minleaf, nfeat){
store <- Dict$new(items = NULL)
root_split <- get_split(x, y, nfeat)
# Get the attribute names
attributes <- colnames(x)
root_name <- attributes[unlist(root_split[1])]
tree <- Node$new(root_name, split_point = root_split[2], data_l = root_split[3], data_r = root_split[4])
tree$AddChild(root_name, split_point = root_split[2], data_l = root_split[3], data_r = root_split[4])
print(tree, "split_point", "data_l", "data_r")
}
tree.grow(credit.x, credit.y, 2, 1, credit.nfeat)
tree.grow <- function(x, y, nmin, minleaf, nfeat){
store <- Dict$new(items = NULL)
root_split <- get_split(x, y, nfeat)
# Get the attribute names
attributes <- colnames(x)
root_name <- attributes[unlist(root_split[1])]
tree <- Node$new(root_name, split_point = root_split[2], data_l = root_split[3], data_r = root_split[4])
tree$AddChild(root_name, split_point = root_split[2], data_l = root_split[3], data_r = root_split[4])
print(tree, "split_point", "data_l", "data_r")
plot(tree)
}
tree.grow(credit.x, credit.y, 2, 1, credit.nfeat)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
source('C:/Users/Lisa/Desktop/UU/Data_Mining_2019/Assignment_1_code.R', echo=TRUE)
